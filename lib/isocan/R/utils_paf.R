#utilities.

# @param file A one-length char vector. A path to a sam file generated by minimap2 with --cs argument.
read_sam <- function(file){
  suppressWarnings(
    readr::read_tsv(file,
                  col_names = c("seq_id", "flag", "chr", "start", "cs"),
                  col_types = "cici_________________c",
                  comment = "@")) %>%
    mutate(cs = str_remove(cs, "^cs:Z::"),
                  strand = if_else(intToBits(flag)[5] == 1, "-", "+", NA_char_),
                  chimera = if_else(intToBits(flag)[12] == 1, T, F))
}

#' read a *.paf file
#'
#' @description read a paf file generated by minimap2 with --cs argument.
#' It is a wrapper of readr::read_tsv.
#' @param file A one-length char vector.
#' @param .query_position A logical.
#' @return a tibble with columns: seq_id, query_length, strand, chr, start, end, and cs.
#' @export
read_paf <- function(file, .query_position = FALSE){
  suppressWarnings({
    lines_raw <- readr::read_lines(file, n_max = 20)
    lines <- stringr::str_subset(lines_raw, "\tcs:Z::")
    if (length(lines) == 0L) {
      if (length(lines_raw) == 20L) stop("The paf file does not contain the 'cs' field in their first 20 lines.")
      else {
        res <- 
          dplyr::tibble(
            seq_id = "",
            query_length = 0L,
            query_start = 0L,
            query_end = 0L,
            strand = "",
            chr = "",
            start = 0L,
            end = 0L,
            cs = "",
            .name_repair = "minimal"
          )[0,]
        if (.query_position == FALSE) {
          res <- dplyr::select(res, -c(query_start, query_end))
        }
        return(res)
      }
    }
    n_column <- max(stringr::str_count(lines, "\t")) + 1L
    cs_idx_raw <- stringr::str_count(stringr::str_remove(lines, "\tcs:Z::.*$"), "\t") + 2L
    cs_idx <- max(cs_idx_raw)
    if (!cs_idx > 9L) {
      message(paste0("cs_idx is the maximum of ", stringr::str_c(cs_idx_raw, collapse = ",") , "."))
      stop("cs_idx is not larger than 9.")
    }
    stopifnot(n_column >= cs_idx)
    former_skip <- paste0(rep("_", cs_idx - 10L), collapse = "")
    after_skip <- paste0(rep("_", n_column - cs_idx), collapse = "")
    if (.query_position == TRUE) {
      types_head <-  "ciiicc_ii"
      coln <- c("seq_id", "query_length", "query_start", "query_end", "strand", "chr", "start", "end", "cs")
    } else {
      types_head <- "ci__cc_ii"
      coln <- c("seq_id", "query_length", "strand", "chr", "start", "end", "cs")
    }
    types <- paste0(types_head, former_skip, "c", after_skip, collapse = "")
    tmp <- readr::read_tsv(file, col_names = coln, col_types = types)
    })
  tmp <- dplyr::mutate(tmp, cs = stringr::str_remove(cs, "^cs:Z::"))
  tmp_fail <- dplyr::filter(tmp, !stringr::str_detect(cs, "^[:digit:]"))
  if (nrow(tmp_fail) > 0){
    warning(stringr::str_c(nrow(tmp_fail), " parsing failures were detected. Skipped."))
    print(tmp_fail)
  }
  anti_join(tmp, tmp_fail, by = colnames(tmp))
}

#' convert paf data into a tibble suitable for "isodata" class.
#'
#' @description "type" column contains "+", "-", "*", or "~".
#' "+": insertion, "-": deletion, "*": substitution, "~": spliced intron.
#' These indicators are equal to those used in minimap2.
#' @param paf A tbl. A paf file generated by minimap2 with --cs argument and read by read_paf.
#' @param sample_name A one-length character vector. Used to fill the "sample" column.
#' @param withcare Logical. If true, stop when a transcript's end position is NOT consistent between described one and calculated one.
#' @param verbose Logical.
#' @param parallel Logical. If true, use furrr::future_map instead of purrr::map
#' @return A tibble with columns: seq_id, chr, type, start, end, ref, alt, and sample.
#' start, end: 0-based. the bases between them present in ref. If insertion, start == end. If point mutation, start + 1 == end.
#' @export
convert_paf_variant <- function(paf, sample_name, withcare = F, verbose = T, parallel = T){
  if (length(sample_name) != 1) stop("The length of sample_name must be 1.")
  if (requireNamespace("furrr")) {
    map_choice <- furrr::future_map
    if (verbose) map_choice <- purrr::partial(furrr::future_map, .progress = TRUE)
  } else {
    map_choice <- purrr::map
  }

  if (verbose) message("convert cs tag to variant...")
  paf %>%
    mutate(variant = map_choice(paf$cs, convert_cs_variant)) %>%
    tidyr::unnest() %>%
    mutate(var_start = var_start + start,
                  var_end = var_end + start) -> paf

  if(withcare){
    if (verbose) message("check...")
    paf %>%
      filter(type == "") %>%
      mutate(success = (end == var_end)) %>%
      filter(success == F) -> fail
    if(nrow(fail) > 0) stop(str_c("Some transcript(s) was failed to convert: ", str_c(fail$seq_id, collapse = ", ")))
  }

  if (verbose) message("filtering......")
  paf %>%
    filter(type != "") %>%
    rename("tx_start" = "start",
           "tx_end" = "end",
           "tx_strand" = "strand",
           "start" = "var_start",
           "end" = "var_end") %>%
    select("seq_id", "chr", "type", "start", "end", "ref", "alt", "tx_start", "tx_end", "tx_strand") %>%
    mutate(sample = sample_name)
}

convert_cs_variant <- function(char){
  #important sub-function.
  char %>%
    str_split(":") %>% .[[1]] %>%
    sapply(separate_multivariant) %>%
    str_split(":") %>% purrr::flatten_chr() %>%
    map_vec_dfr(section2vector,
                   .colnames = c("last_match_len", "type", "len", "ref", "alt")) %>%
    mutate(last_match_len = as.numeric(last_match_len),
                  len = as.numeric(len),
                  after_len = last_match_len + len,
                  var_end = purrr::accumulate(after_len, sum),
                  var_start = var_end - len,
           ref = str_to_lower(ref),
           alt = str_to_lower(alt)) %>%
    select_("type", "var_start", "var_end", "ref", "alt")
}

#for(i in 17:100) convert_cs_variant(tmp$cs[i]) %>% is.na() %>% sum() %>% as.logical() %>% i[.] %>% print()

separate_multivariant <- function(char){
  char %>%
    str_replace("[-\\+\\*~].+[-\\+\\*~]", insert_colon)
}

insert_colon <- function(char){
  char %>%
    str_replace("[-\\+\\*~]", replace_to_dammy) %>% #replace the first +,-,*, or ~
    str_replace_all("[-\\+\\*~]", function(.x) {if(is.na(char)) {NA_character_} else paste0(":0", .x)}) %>%
    str_replace("[<>@#]", recover_from_dammy)
}

replace_to_dammy <- function(char){
  if(is.na(char)) NA_character_
  else if(char == "+") "<"
  else if(char == "-") ">"
  else if(char == "*") "@"
  else if(char == "~") "#"
  else char
}

recover_from_dammy <- function(char){
  if(is.na(char)) NA_character_
  else if(char == "<") "+"
  else if(char == ">") "-"
  else if(char == "@") "*"
  else if(char == "#") "~"
  else char
}

insert_colon_ast <- function(char){
  str_replace(char, "\\*", ":0\\*")
}

map_vec_dfr <- function(.x, .f, ..., .colnames = NULL){
  #.f is a function which returns a fixed length vector.
  purrr::map(.x, .f, ...) %>%
    purrr::transpose(.names = .colnames) %>%
    tibble::as_tibble() %>%
    tidyr::unnest()
}

section2vector <- function(section){
  #important sub function.
  #return a vector: c(int_last_match_length, [-,+,*,~,""], int_length, chr_ref, chr_alt)
  #at the last match part, che_ref and chr_alt equal to ""
  section %>%
    str_replace("-", ",-,0,") %>% #del #0 is dammy length
    str_replace("\\+", ",\\+,0,") %>% #ins
    str_replace("\\*", ",\\*,1,") %>% #snv
    str_replace("~[:alpha:]{2}", ",~,") %>% #sj
    str_replace("[:digit:]+[:alpha:]{2}$", function(.x) paste0(left_only_int(.x), ",")) %>%  #sj
    modify_only_int() %>% #last match part
    str_split(",") %>%
    .[[1]] %>%
    modify_del_length() %>%
    split_ref_alt()
  }

left_only_int <- function(char){
  if(is.na(char)) NA_character_
  else str_extract(char, "[:digit:]+")
}

modify_only_int <- function(char){
  if(str_detect(char, "^[:digit:]+$")){
    char <- paste0(char, ",,0,")
  }
  return(char)
}

modify_del_length <- function(vector){
  if(vector[2] == "-"){
    vector[3] <- str_length(vector[4])
  }
  return(vector)
}

split_ref_alt <- function(vector){
  vector <- c(vector, "")
  if(vector[2] == "+"){
    vector[5] <- vector[4]
    vector[4] <- ""
  }else if(vector[2] == "*"){
    vector[5] <- str_sub(vector[4], 2, 2)
    vector[4] <- str_sub(vector[4], 1, 1)
  }
  return(vector)
}
